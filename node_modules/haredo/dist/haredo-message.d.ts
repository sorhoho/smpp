import { Message, MessagePropertyHeaders } from 'amqplib';
import { TypedEventEmitter } from './events';
export interface HaredoMessageEvents {
    handled: void;
}
export interface HaredoMessage<TMessage = unknown, TReply = unknown> extends Methods<TReply> {
    metaType: 'message';
    emitter: TypedEventEmitter<HaredoMessageEvents>;
    /**
     * Raw message from amqplib
     */
    raw: Message;
    /**
     * Message contents
     */
    data: TMessage;
    /**
     * Unparsed message data
     */
    dataString: string;
    /**
     * Returns true if message has been acked/nacked
     */
    isHandled(): boolean;
    /**
     * Returns true if the message has been nacked
     */
    isNacked(): boolean;
    /**
     * Returns true if the message has been acked
     */
    isAcked(): boolean;
    /**
     * Returns true if the message has been replied to (RPC)
     */
    isReplied(): boolean;
    /**
     * Returns the reply that was sent ack (RPC)
     */
    getReply(): TReply;
    /**
     * Headers of the message
     */
    headers: MessagePropertyHeaders;
    /**
     * Return the specified header
     * @param header header to return
     */
    getHeader(header: string): string | string[];
    contentType?: string;
    contentEncoding?: string;
    /**
     * Either 1 for non-persistent or 2 for persistent
     */
    deliveryMode?: 1 | 2;
    /**
     * Priority of a message. See [priority queues](https://www.rabbitmq.com/priority.html)
     */
    priority?: number;
    /**
     * Used for RPC system to match messages to their replies
     */
    correlationId?: string;
    /**
     * Queue name to reply to for RPC
     */
    replyTo?: string;
    /**
     * If supplied, the message will be discarded from a queue once itâ€™s been there longer than the given number of milliseconds
     */
    expiration?: number;
    /**
     * Arbitrary application-specific identifier for the message
     */
    messageId?: string;
    /**
     * A timestamp for the message
     */
    timestamp?: number;
    /**
     * An arbitrary application-specific type for the message
     */
    type?: string;
    /**
     * If supplied, RabbitMQ will compare it to the username supplied when opening the connection, and reject messages for which it does not match
     */
    userId?: string;
    /**
     * An arbitrary identifier for the originating application
     */
    appId?: string;
    /**
     * consumerTag of the consumer the message originates from
     */
    consumerTag?: string;
    /**
     * deliveryTag of the message (used to identify the message between consumer and broker)
     */
    deliveryTag: number;
    /**
     * True if the message has been sent to a consumer at least once
     */
    redelivered: boolean;
    /**
     * Name of the exchange the message originates from
     */
    exchange?: string;
    /**
     * Routingkey. If routingkey was not set then this equals to the name of the queue
     */
    routingKey?: string;
    /**
     * Name of the queue this message was consumed from
     */
    queue: string;
    /**
     * Amount of attempts the broker has done to deliver the message
     */
    deliveryCount?: number;
}
export interface Methods<TReply = unknown> {
    /**
     * Mark the message as done, removes it from the queue
     */
    ack(): void;
    /**
     * Nack the message. If requeue is false (defaults to true)
     * then the message will be discarded. Otherwise it will be returned to
     * the front of the queue
     */
    nack(requeue?: boolean): void;
    /**
     * Reply to the message. Only works if the message has a
     * replyTo and correlationId have been set on the message.
     * If autoReply has been set on the chain, then You can just return a
     * non-undefined value from the subscribe callback
     */
    reply(message: TReply): Promise<void>;
}
export declare const makeHaredoMessage: <TMessage = unknown, TReply = unknown>(raw: Message, parseJson: boolean, queue: string, methods: Methods<TReply>) => HaredoMessage<TMessage, TReply>;
/**
 * Returns true if passed in object is an message. Acts as a type guard for Message.
 * @param obj Object to check
 */
export declare const isHaredoMessage: (obj: any) => obj is Message;
