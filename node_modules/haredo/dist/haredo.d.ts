import { Message, Options } from 'amqplib';
import { FailureBackoff } from './backoffs';
import { ConnectionOptions } from './connection-manager';
import { Consumer, MessageCallback } from './consumer';
import { Exchange, ExchangeOptions, ExchangeType, StandardExchangeType } from './exchange';
import { HaredoMessage } from './haredo-message';
import { MessageChain } from './prepared-message';
import { Queue } from './queue';
import { HaredoChainState, Middleware } from './state';
import { MergeTypes } from './utils';
export interface LogItem {
    level: LogLevel;
    component: string;
    msg: string;
    message?: HaredoMessage;
    rawMessage?: Message;
    error?: Error;
    timestamp: Date;
}
export interface HaredoOptions {
    connection?: ConnectionOptions | string;
    socketOpts?: any;
    logger?(log: LogItem): void;
}
export declare enum LogLevel {
    'DEBUG' = "DEBUG",
    'INFO' = "INFO",
    'WARNING' = "WARNING",
    'ERROR' = "ERROR"
}
export interface Haredo extends InitialChain<unknown, unknown> {
    /**
     * Cancel all consumers, wait for them to finish processing their messages
     * and then close the connection to the broker
     */
    close(): Promise<void>;
    /**
     * Connect to RabbitMQ. Note: this is not needed, Haredo connects automatically
     */
    connect(): Promise<void>;
}
export declare const haredo: ({ connection, socketOpts, logger }: HaredoOptions) => Haredo;
export interface ChainFunction<TMessage = unknown> {
    (state: Partial<HaredoChainState<TMessage>>): any;
}
export declare const initialChain: <TMessage, TReply>(state: Partial<HaredoChainState<TMessage, unknown>>) => InitialChain<TMessage, TReply>;
export declare const chainMethods: <TChain extends ChainFunction<unknown>, TMessage>(chain: TChain) => (state: Partial<HaredoChainState<TMessage, unknown>>) => GeneralChainMembers<TChain>;
export declare const exchangeChain: <TMessage, TReply>(state: Partial<HaredoChainState<TMessage, unknown>>) => ExchangeChain<TMessage, TReply>;
export declare const queueChain: <TMessage, TReply>(state: Partial<HaredoChainState<TMessage, unknown>>) => QueueChain<TMessage, TReply>;
export declare const rpcToQueue: <TMessage, TReply>(state: Partial<HaredoChainState<TMessage, TReply>>) => (message: TMessage, opts: Options.Publish) => Promise<TReply>;
interface RpcToExchange<TMessage, TReply> {
    /**
     * Send an RPC message to the provided exchange.
     * Unless .json(false) is present in the chain,
     * the message will be passed through JSON.stringify
     */
    (message: TMessage | string, routingKey?: string, options?: Options.Publish): Promise<TReply>;
    /**
     * Send an RPC message to the provided exchange.
     * If you provide a truthy routingKey,
     * it will override the one specified in MessageChain
     */
    (message: MessageChain<TMessage>, routingKey?: string, options?: Options.Publish): Promise<TReply>;
}
export declare const rpcToExchange: <TMessage, TReply>(state: Partial<HaredoChainState<TMessage, TReply>>) => RpcToExchange<TMessage, TReply>;
export declare const publishToQueue: <TMessage>(state: Partial<HaredoChainState<TMessage, unknown>>) => (message: TMessage | MessageChain<TMessage>, options?: Options.Publish) => Promise<void>;
interface PublishToExchange<TMessage> {
    /**
     * Publish a message to the exchange.
     * Unless the chain contains .json(false),
     * the message will be passed through JSON.stringify
     */
    (message: TMessage | string, routingKey?: string, options?: Options.Publish): Promise<void>;
    /**
     * Publish a message to the exchange.
     * If you provide a truthy routingKey,
     * it will override the one specified in MessageChain
     */
    (message: MessageChain<TMessage>, routingKey?: string, options?: Options.Publish): Promise<void>;
}
export declare const publishToExchange: <TMessage>(state: Partial<HaredoChainState<TMessage, unknown>>) => PublishToExchange<TMessage>;
export declare const addQueue: <T extends ChainFunction<unknown>>(chain: T) => (state: Partial<HaredoChainState>) => (queue: string | Queue, opts?: Options.AssertQueue) => any;
export declare const addExchange: <T extends ChainFunction<unknown>>(chain: T) => (state: Partial<HaredoChainState>) => (exchange: Exchange | string, type: ExchangeType, opts?: Partial<ExchangeOptions>) => any;
export declare const addExchangeBinding: <TMessage, TChain extends ChainFunction<TMessage>, TCustom, TCustomChain extends ChainFunction<TCustom>>(chain: TChain) => (state: Partial<HaredoChainState<TMessage, unknown>>) => <TCustom_1>(exchange: string | Exchange<TCustom_1>, pattern: string | string[], type?: ExchangeType, opts?: Partial<ExchangeOptions>) => ReturnType<TChain> | ReturnType<TCustomChain>;
export declare const addJson: <T extends ChainFunction<unknown>>(chain: T) => (state: Partial<HaredoChainState>) => (json?: boolean) => ReturnType<T>;
interface GeneralChainMembers<TChain extends ChainFunction> {
    /**
     * Enable publishing using ConfirmChannels
     *
     * See [RabbitMq Docs](https://www.rabbitmq.com/confirms.html)
     *
     * @param confirm defaults to true
     */
    confirm(confirm?: boolean): ReturnType<TChain>;
    /**
     * Enable json mode (it's enabled by default).
     * When json is enabled, messages that are published without using prepared message objects
     * will be passed through JSON.stringify. When subscribing message data will
     * be run through JSON.parse
     *
     * @param json defaults to true
     */
    json(json?: boolean): ReturnType<TChain>;
    /**
     * Assert / Bind exchanges/queues. Will be skipped if skipSetup is set in the chain
     */
    setup(): Promise<void>;
}
export interface QueuePublishMethod<TMessage = unknown, TReply = unknown> {
    publish(message: TMessage | MessageChain<TMessage> | string, publishOpts?: Options.Publish): Promise<void>;
    rpc(message: TMessage | MessageChain<TMessage> | string, publishOpts?: Options.Publish): Promise<TReply>;
}
export interface ExchangePublishMethod<TMessage = unknown, TReply = unknown> {
    publish: PublishToExchange<TMessage>;
    rpc: RpcToExchange<TMessage, TReply>;
}
export interface InitialChain<TMessage, TReply> {
    /**
     * Create a queue based chain
     */
    queue<TCustomMessage = unknown, TCustomReply = unknown>(queue: Queue<TCustomMessage, TCustomReply>): QueueChain<MergeTypes<TMessage, TCustomMessage>, MergeTypes<TReply, TCustomReply>>;
    /**
     * Create a queue based chain
     * @param queue name of the queue
     * @param opts optional parameters to pass to [amqplib#AssertQueue](https://www.squaremobius.net/amqp.node/channel_api.html#channel_assertQueue)
     */
    queue<TCustomMessage = unknown, TCustomReply = unknown>(queue: string, opts?: Options.AssertQueue): QueueChain<MergeTypes<TMessage, TCustomMessage>, MergeTypes<TReply, TCustomReply>>;
    /**
    * Create an exchange based chain
    *
    * @param exchange instance of Exchange
    */
    exchange<TCustomMessage = unknown, TCustomReply = unknown>(exchange: Exchange<TCustomMessage>): ExchangeChain<MergeTypes<TMessage, TCustomMessage>, MergeTypes<TReply, TCustomReply>>;
    /**
     * Add an exchange to the chain.
     *
     * @param exchange name of the exchange
     * @param type exchange type, defaults to Direct
     * @param opts exchange options that will be passed to amqplib while asserting
     * [amqplib#assertExchange](https://www.squaremobius.net/amqp.node/channel_api.html#channel_assertExchange)
     */
    exchange<TCustomMessage = unknown, TCustomReply = unknown>(exchange: string, type: ExchangeType | StandardExchangeType, opts?: Partial<ExchangeOptions>): ExchangeChain<MergeTypes<TMessage, TCustomMessage>, MergeTypes<TReply, TCustomReply>>;
}
export interface ExchangeChain<TMessage, TReply> extends GeneralChainMembers<(state: HaredoChainState<TMessage>) => ExchangeChain<TMessage, TReply>>, ExchangePublishMethod<TMessage, TReply> {
    /**
     * Return the state of the chain for inspection
     */
    getState(): Partial<HaredoChainState<TMessage, TReply>>;
    /**
     * Bind an exchange to the main exchange.
     * See [Exchange to Exchange bindings](https://www.rabbitmq.com/e2e.html)
     *
     * For patterns there are two wildcards:
     * * `*` - one word
     * * `#` - zero or more words
     * A word is dot(period) delimited
     *
     * @param exchange Exchange to bind
     * @param pattern Pattern(s) to use
     */
    bindExchange<TCustomMessage = unknown, TCustomReply = unknown>(exchange: Exchange<TCustomMessage>, pattern: string | string[]): ExchangeChain<MergeTypes<TMessage, TCustomMessage>, MergeTypes<TReply, TCustomReply>>;
    /**
     * Assert and bind an exchange to the main exchange.
     * See [Exchange to Exchange bindings](https://www.rabbitmq.com/e2e.html)
     *
     * For patterns there are two wildcards:
     * * `*` - one word
     * * `#` - zero or more words
     * A word is dot(period) delimited
     *
     * @param exchangeName name of the exchange to forward messages from
     * @param pattern pattern(s) to bind
     * @param exchangeType type of the exchange
     * @param exchangeOpts extra options for asserting the exchange
     */
    bindExchange(exchangeName: string, pattern: string | string[], exchangeType: ExchangeType, exchangeOpts?: ExchangeOptions): ExchangeChain<TMessage, TReply>;
    /**
     * Bind an exchange to the main exchange.
     *
     * For patterns there are two wildcards:
     * * `*` - one word
     * * `#` - zero or more words
     * A word is dot(period) delimited
     *
     * @param exchange Name of the exchange to bind
     * @param pattern Pattern(s) to use
     * @param type Type of the exchange
     * @param opts Options to pass to amqplib for asserting
     */
    bindExchange<TCustomMessage = unknown, TCustomReply = unknown>(exchange: string, pattern: string | string[], type: ExchangeType, opts?: Partial<ExchangeOptions>): ExchangeChain<MergeTypes<TMessage, TCustomMessage>, MergeTypes<TReply, TCustomReply>>;
    /**
     * Don't run automatic setup. Useful for faster publishing.
     *
     * @param skipSetup defaults to true
     */
    skipSetup(skipSetup?: boolean): ExchangeChain<TMessage, TReply>;
}
export interface QueueChain<TMessage, TReply> extends GeneralChainMembers<(state: HaredoChainState<TMessage, TReply>) => QueueChain<TMessage, TReply>>, QueuePublishMethod<TMessage, TReply> {
    /**
     * Return the state of the chain for inspection
     */
    getState(): Partial<HaredoChainState<TMessage>>;
    /**
     * Bind an exchange to the queue.
     *
     * For patterns there are two wildcards:
     * * `*` - one word
     * * `#` - zero or more words
     * A word is dot(period) delimited
     *
     * @param exchange Exchange to bind
     * @param pattern Pattern(s) to use
     */
    bindExchange<TCustomMessage = unknown, TCustomReply = unknown>(exchange: Exchange<TCustomMessage>, pattern: string | string[]): QueueChain<MergeTypes<TMessage, TCustomMessage>, MergeTypes<TReply, TCustomReply>>;
    /**
     * Bind an exchange to the queue.
     *
     * For patterns there are two wildcards:
     * * `*` - one word
     * * `#` - zero or more words
     * A word is dot(period) delimited
     *
     * @param exchangeName name of the exchange
     * @param pattern pattern(s) to bind
     * @param exchangeType Type of the exchange
     * @param exchangeOpts Options to use for asserting the exchange
     */
    bindExchange(exchangeName: string, pattern: string | string[], exchangeType: ExchangeType, exchangeOpts?: ExchangeOptions): QueueChain<TMessage, TReply>;
    /**
     * Bind an exchange to the queue.
     *
     * For patterns there are two wildcards:
     * * `*` - one word
     * * `#` - zero or more words
     * A word is dot(period) delimited
     *
     * @param exchange Name of the exchange to bind
     * @param pattern Pattern(s) to use
     * @param type Type of the exchange
     * @param opts Options to pass to amqplib for asserting
     */
    bindExchange<TCustomMessage = unknown, TCustomReply = unknown>(exchange: string, pattern: string | string[], type: ExchangeType, opts?: Partial<ExchangeOptions>): QueueChain<MergeTypes<TMessage, TCustomMessage>, MergeTypes<TReply, TCustomReply>>;
    /**
     * Enable noAck on the consumer. When noAck is set the broker will dequeue
     * messages when they are sent down the wire.
     *
     * @param noAck defaults to true
     */
    noAck(noAck?: boolean): QueueChain<TMessage, TReply>;
    /**
     * Set the consumer priority. Lower priority consumers will receive messages only when higher
     * priority consumers are busy.
     *
     * Requires [Consumer priorities](https://www.rabbitmq.com/consumer-priority.html) extension to be enabled
     */
    priority(priority: number): QueueChain<TMessage, TReply>;
    /**
     * When exclusive is set to true, the broker won't allow anyone else consume from this queue
     * @param exclusive defaults to true
     */
    exclusive(exclusive?: boolean): QueueChain<TMessage, TReply>;
    /**
     * Autoack (enabled by default) automatically acks/nacks messages when
     * subscriber callback throws an error or the promise returned from it
     * gets rejected.
     *
     * @param autoAck defaults to true
     */
    autoAck(autoAck?: boolean): QueueChain<TMessage, TReply>;
    /**
     * Set prefetch count for consuming (ie. amount of messages that will be received in parallel)
     * 0 Means there is no limit
     *
     * @param prefetch number of messages to prefetch
     */
    prefetch(prefetch: number): QueueChain<TMessage, TReply>;
    /**
     * Reestablish a subscriber when channel / connection closes (enabled by default)
     *
     * @param reestablish defaults to true
     */
    reestablish(reestablish?: boolean): QueueChain<TMessage, TReply>;
    /**
     * Subscribe to messages in the queue specified in the chain
     */
    subscribe<TCustomMessage, TCustomReply>(cb: MessageCallback<MergeTypes<TMessage, TCustomMessage>, MergeTypes<TReply, TCustomReply>>): Promise<Consumer>;
    /**
     * Autoreply (enabled by default) automatically replies to messages
     * where message callback in subscriber returns a non-undefined value
     * (Only if message has replyTo and a correlationId)
     *
     * [RPC tutorial](https://www.rabbitmq.com/tutorials/tutorial-six-javascript.html)
     *
     * @param autoReply defaults to true
     */
    autoReply(autoReply?: boolean): QueueChain<TMessage, TReply>;
    /**
     * Provide a failurebackoff to control the rate of messages in case of errors.
     * Bundled together with haredo comes standardBackoff
     */
    backoff(backoff: FailureBackoff): QueueChain<TMessage, TReply>;
    /**
     * Don't run automatic setup. Useful for faster publishing.
     *
     * @param skipSetup defaults to true
     */
    skipSetup(skipSetup?: boolean): QueueChain<TMessage, TReply>;
    /**
     * Add middleware to the subscription
     */
    use(middleware: Middleware<TMessage, TReply> | Middleware<TMessage, TReply>[]): QueueChain<TMessage, TReply>;
}
export {};
