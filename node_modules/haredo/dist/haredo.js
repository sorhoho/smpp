"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addJson = exports.addExchangeBinding = exports.addExchange = exports.addQueue = exports.publishToExchange = exports.publishToQueue = exports.rpcToExchange = exports.rpcToQueue = exports.queueChain = exports.exchangeChain = exports.chainMethods = exports.initialChain = exports.haredo = exports.LogLevel = void 0;
const connection_manager_1 = require("./connection-manager");
const consumer_1 = require("./consumer");
const exchange_1 = require("./exchange");
const prepared_message_1 = require("./prepared-message");
const queue_1 = require("./queue");
const rpc_1 = require("./rpc");
const state_1 = require("./state");
const utils_1 = require("./utils");
const errors_1 = require("./errors");
var LogLevel;
(function (LogLevel) {
    LogLevel["DEBUG"] = "DEBUG";
    LogLevel["INFO"] = "INFO";
    LogLevel["WARNING"] = "WARNING";
    LogLevel["ERROR"] = "ERROR";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
const makeLogger = (level, logger) => ({ component, msg, message, rawMessage, error }) => logger(utils_1.omitUndefined({ component, msg, message, rawMessage, error, level, timestamp: new Date() }));
exports.haredo = ({ connection, socketOpts, logger = () => { } }) => {
    validateConnectionOptions(connection);
    const log = {
        debug: makeLogger(LogLevel.DEBUG, logger),
        info: makeLogger(LogLevel.INFO, logger),
        warning: makeLogger(LogLevel.WARNING, logger),
        error: makeLogger(LogLevel.ERROR, logger)
    };
    const connectionManager = connection_manager_1.makeConnectionManager(connection, socketOpts, log);
    return Object.assign(Object.assign({}, exports.initialChain(utils_1.merge(state_1.defaultState(), { connectionManager, log }))), { close: async () => {
            await connectionManager.close();
        }, connect: async () => {
            await connectionManager.getConnection();
        } });
};
const validateConnectionOptions = (connectionOpts) => {
    if (typeof connectionOpts === 'string') {
        return;
    }
    const allowedKeys = ['frameMax', 'heartbeat', 'hostname', 'locale', 'password', 'port', 'protocol', 'username', 'vhost', 'reconnectDelays'];
    for (const key of Object.keys(connectionOpts)) {
        if (!allowedKeys.includes(key)) {
            throw new errors_1.InvalidOptionsError(key);
        }
    }
};
exports.initialChain = (state) => {
    return {
        queue: exports.addQueue(exports.queueChain)(state),
        exchange: exports.addExchange(exports.exchangeChain)(state)
    };
};
const addSetup = (state) => async () => {
    var _a;
    if (state.skipSetup) {
        return;
    }
    const channel = await state.connectionManager.getChannel();
    let channelIsClosed = false;
    channel.on('close', () => {
        channelIsClosed = true;
    });
    try {
        if (typeof state.queue !== 'undefined') {
            const _b = state.queue.getOpts(), { preferences } = _b, queueOpts = __rest(_b, ["preferences"]);
            let queueData;
            const queueInitialName = state.queue.getName();
            // amq. prefixed queue names are only allowed as server-assigned.
            // In case of reconnection we want to wipe the name and let server
            // assign a new name.
            const queueName = /^amq\./.test(queueInitialName) ? '' : queueInitialName;
            if (preferences === null || preferences === void 0 ? void 0 : preferences.passive) {
                queueData = await channel.checkQueue(queueName);
            }
            else {
                queueData = await channel.assertQueue(queueName, queueOpts);
            }
            state.queue.mutateName(queueData.queue);
        }
        if (state.exchange) {
            const _c = state.exchange.getOpts(), { preferences } = _c, exchangeOpts = __rest(_c, ["preferences"]);
            if (preferences === null || preferences === void 0 ? void 0 : preferences.passive) {
                await channel.checkExchange(state.exchange.getName());
            }
            else {
                await channel.assertExchange(state.exchange.getName(), state.exchange.getType(), exchangeOpts);
            }
        }
        if ((_a = state.bindings) === null || _a === void 0 ? void 0 : _a.length) {
            await utils_1.promiseMap(state.bindings, async (binding) => {
                const _a = binding.exchange.getOpts(), { preferences } = _a, exchangeOpts = __rest(_a, ["preferences"]);
                if (preferences === null || preferences === void 0 ? void 0 : preferences.passive) {
                    await channel.checkExchange(binding.exchange.getName());
                }
                else {
                    await channel.assertExchange(binding.exchange.getName(), binding.exchange.getType(), exchangeOpts);
                }
                await utils_1.promiseMap(binding.patterns, async (pattern) => {
                    if (state.queue) {
                        await channel.bindQueue(state.queue.getName(), binding.exchange.getName(), pattern);
                    }
                    else {
                        await channel.bindExchange(state.exchange.getName(), binding.exchange.getName(), pattern);
                    }
                });
            });
        }
    }
    finally {
        if (!channelIsClosed) {
            await channel.close();
        }
    }
};
exports.chainMethods = (chain) => (state) => ({
    json: exports.addJson(chain)(state),
    setup: addSetup(state),
    confirm: addConfirm(chain)(state)
});
exports.exchangeChain = (state) => {
    const bindExchange = exports.addExchangeBinding(exports.exchangeChain)(state);
    return Object.assign(Object.assign({ bindExchange, getState: () => state }, exports.chainMethods(exports.exchangeChain)(state)), { publish: exports.publishToExchange(state), rpc: exports.rpcToExchange(state), skipSetup: (skipSetup = true) => {
            return exports.exchangeChain(utils_1.merge(state, { skipSetup }));
        } });
};
exports.queueChain = (state) => {
    const bindExchange = exports.addExchangeBinding(exports.queueChain)(state);
    return Object.assign(Object.assign({ bindExchange }, exports.chainMethods(exports.queueChain)(state)), { publish: exports.publishToQueue(state), rpc: exports.rpcToQueue(state), getState: () => state, subscribe: async (cb) => {
            var _a, _b, _c, _d, _e, _f;
            const consumer = await consumer_1.makeConsumer(cb, state.connectionManager, {
                autoAck: (_a = state.autoAck) !== null && _a !== void 0 ? _a : true,
                json: (_b = state.json) !== null && _b !== void 0 ? _b : true,
                middleware: state.middleware,
                autoReply: (_c = state.autoReply) !== null && _c !== void 0 ? _c : false,
                prefetch: state.prefetch,
                queue: state.queue,
                reestablish: (_d = state.reestablish) !== null && _d !== void 0 ? _d : true,
                backoff: state.backoff,
                noAck: (_e = state.noAck) !== null && _e !== void 0 ? _e : false,
                priority: state.priority,
                exclusive: (_f = state.exclusive) !== null && _f !== void 0 ? _f : false,
                setup: addSetup(state)
            }, state.log);
            state.connectionManager.addConsumer(consumer);
            return consumer;
        }, autoAck: (autoAck = true) => {
            return exports.queueChain(utils_1.merge(state, { autoAck }));
        }, prefetch: (prefetch = 0) => {
            return exports.queueChain(utils_1.merge(state, { prefetch }));
        }, reestablish: (reestablish = true) => {
            return exports.queueChain(utils_1.merge(state, { reestablish }));
        }, autoReply: (autoReply = true) => {
            return exports.queueChain(utils_1.merge(state, { autoReply }));
        }, backoff: (backoff) => {
            return exports.queueChain(utils_1.merge(state, { backoff }));
        }, skipSetup: (skipSetup = true) => {
            return exports.queueChain(utils_1.merge(state, { skipSetup }));
        }, use: (...middleware) => {
            return exports.queueChain(utils_1.merge(state, { middleware: (state.middleware || []).concat(middleware) }));
        }, noAck: (noAck = true) => {
            return exports.queueChain(utils_1.merge(state, { noAck }));
        }, priority: (priority) => {
            return exports.queueChain(utils_1.merge(state, { priority }));
        }, exclusive: (exclusive = true) => {
            return exports.queueChain(utils_1.merge(state, { exclusive }));
        } });
};
exports.rpcToQueue = (state) => async (message, opts) => {
    await addSetup(state)();
    const correlationId = rpc_1.generateCorrelationId();
    const { promise, queue } = await state.connectionManager.rpc(correlationId);
    const preppedMessage = prepMessage(state, message, undefined, opts)
        .correlationId(correlationId)
        .replyTo(queue)
        .getState();
    await state.connectionManager.publisher.sendToQueue(state.queue.getName(), Buffer.from(preppedMessage.content), preppedMessage.options, state.confirm);
    return promise;
};
exports.rpcToExchange = (state) => async (message, routingKey, options = {}) => {
    await addSetup(state)();
    const correlationId = rpc_1.generateCorrelationId();
    const { promise, queue } = await state.connectionManager.rpc(correlationId);
    const preppedMessage = prepMessage(state, message, routingKey, options)
        .correlationId(correlationId)
        .replyTo(queue)
        .getState();
    await state.connectionManager.publisher.publishToExchange(state.exchange.getName(), preppedMessage.routingKey, Buffer.from(preppedMessage.content), preppedMessage.options, state.confirm);
    return promise;
};
const prepMessage = (state, message, routingKey, options = {}) => {
    if (!prepared_message_1.isHaredoPreparedMessage(message)) {
        if (state.json) {
            message = prepared_message_1.preparedMessage({}).json(message);
        }
        else {
            message = prepared_message_1.preparedMessage({}).rawContent(message);
        }
    }
    if (routingKey) {
        message = message.routingKey(routingKey);
    }
    message = prepared_message_1.preparedMessage(prepared_message_1.mergeMessageState(message.getState(), { options }));
    return message;
};
exports.publishToQueue = (state) => async (message, options = {}) => {
    const preppedMessage = prepMessage(state, message, undefined, options).getState();
    await addSetup(state)();
    return state.connectionManager.publisher.sendToQueue(state.queue.getName(), Buffer.from(preppedMessage.content), preppedMessage.options, state.confirm);
};
exports.publishToExchange = (state) => async (message, routingKey, options) => {
    const preppedMessage = prepMessage(state, message, routingKey, options).getState();
    await addSetup(state)();
    return state.connectionManager.publisher.publishToExchange(state.exchange.getName(), preppedMessage.routingKey, Buffer.from(preppedMessage.content), preppedMessage.options, state.confirm);
};
exports.addQueue = (chain) => (state) => (queue, opts = {}) => {
    if (typeof queue === 'string') {
        queue = queue_1.makeQueueConfig(queue, opts);
    }
    return chain(utils_1.merge(state, { queue }));
};
exports.addExchange = (chain) => (state) => (exchange, type, opts = {}) => {
    if (typeof exchange === 'string') {
        exchange = exchange_1.makeExchangeConfig(exchange, type, opts);
    }
    return chain(utils_1.merge(state, { exchange }));
};
exports.addExchangeBinding = (chain) => (state) => (exchange, pattern, type, opts = {}) => {
    if (typeof exchange === 'string') {
        exchange = exchange_1.makeExchangeConfig(exchange, type, opts);
    }
    return chain(utils_1.merge(state, { bindings: (state.bindings || [])
            .concat({ exchange, patterns: [].concat(pattern) }) }));
};
const addConfirm = (chain) => (state) => (confirm = true) => chain(utils_1.merge(state, { confirm }));
exports.addJson = (chain) => (state) => (json = true) => chain(utils_1.merge(state, { json }));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFyZWRvLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2hhcmVkby50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUVBLDZEQUFnRjtBQUNoRix5Q0FBcUU7QUFDckUseUNBQStHO0FBRS9HLHlEQUF1STtBQUN2SSxtQ0FBaUQ7QUFDakQsK0JBQThDO0FBQzlDLG1DQUFzRjtBQUN0RixtQ0FBdUU7QUFDdkUscUNBQStDO0FBc0IvQyxJQUFZLFFBS1g7QUFMRCxXQUFZLFFBQVE7SUFDaEIsMkJBQWlCLENBQUE7SUFDakIseUJBQWUsQ0FBQTtJQUNmLCtCQUFxQixDQUFBO0lBQ3JCLDJCQUFpQixDQUFBO0FBQ3JCLENBQUMsRUFMVyxRQUFRLEdBQVIsZ0JBQVEsS0FBUixnQkFBUSxRQUtuQjtBQWNELE1BQU0sVUFBVSxHQUFHLENBQUMsS0FBZSxFQUFFLE1BQThCLEVBQVUsRUFBRSxDQUMzRSxDQUFDLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsQ0FDL0MsTUFBTSxDQUFDLHFCQUFhLENBQUMsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsSUFBSSxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUUvRixRQUFBLE1BQU0sR0FBRyxDQUFDLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxNQUFNLEdBQUcsR0FBRyxFQUFFLEdBQUUsQ0FBQyxFQUFpQixFQUFVLEVBQUU7SUFDM0YseUJBQXlCLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDdEMsTUFBTSxHQUFHLEdBQVk7UUFDakIsS0FBSyxFQUFFLFVBQVUsQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQztRQUN6QyxJQUFJLEVBQUUsVUFBVSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDO1FBQ3ZDLE9BQU8sRUFBRSxVQUFVLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUM7UUFDN0MsS0FBSyxFQUFFLFVBQVUsQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQztLQUM1QyxDQUFDO0lBQ0YsTUFBTSxpQkFBaUIsR0FBRywwQ0FBcUIsQ0FBQyxVQUFVLEVBQUUsVUFBVSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQzdFLHVDQUNPLG9CQUFZLENBQUMsYUFBSyxDQUFDLG9CQUFZLEVBQW9CLEVBQUUsRUFBRSxpQkFBaUIsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLEtBQ3BGLEtBQUssRUFBRSxLQUFLLElBQUksRUFBRTtZQUNkLE1BQU0saUJBQWlCLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDcEMsQ0FBQyxFQUNELE9BQU8sRUFBRSxLQUFLLElBQUksRUFBRTtZQUNoQixNQUFNLGlCQUFpQixDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQzVDLENBQUMsSUFDSDtBQUNOLENBQUMsQ0FBQztBQUVGLE1BQU0seUJBQXlCLEdBQUcsQ0FBQyxjQUEwQyxFQUFFLEVBQUU7SUFDN0UsSUFBSSxPQUFPLGNBQWMsS0FBSyxRQUFRLEVBQUU7UUFDcEMsT0FBTztLQUNWO0lBQ0QsTUFBTSxXQUFXLEdBQWdDLENBQUMsVUFBVSxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztJQUN6SyxLQUFLLE1BQU0sR0FBRyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUU7UUFDM0MsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsR0FBNEIsQ0FBQyxFQUFFO1lBQ3JELE1BQU0sSUFBSSw0QkFBbUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUN0QztLQUNKO0FBQ0wsQ0FBQyxDQUFDO0FBTVcsUUFBQSxZQUFZLEdBQUcsQ0FBbUIsS0FBMEMsRUFBa0MsRUFBRTtJQUN6SCxPQUFPO1FBQ0gsS0FBSyxFQUFFLGdCQUFRLENBQUMsa0JBQVUsQ0FBQyxDQUFDLEtBQUssQ0FBQztRQUNsQyxRQUFRLEVBQUUsbUJBQVcsQ0FBQyxxQkFBYSxDQUFDLENBQUMsS0FBSyxDQUFDO0tBQ1osQ0FBQztBQUN4QyxDQUFDLENBQUM7QUFFRixNQUFNLFFBQVEsR0FBRyxDQUFDLEtBQWdDLEVBQUUsRUFBRSxDQUFDLEtBQUssSUFBSSxFQUFFOztJQUM5RCxJQUFJLEtBQUssQ0FBQyxTQUFTLEVBQUU7UUFDakIsT0FBTztLQUNWO0lBQ0QsTUFBTSxPQUFPLEdBQUcsTUFBTSxLQUFLLENBQUMsaUJBQWlCLENBQUMsVUFBVSxFQUFFLENBQUM7SUFDM0QsSUFBSSxlQUFlLEdBQUcsS0FBSyxDQUFDO0lBQzVCLE9BQU8sQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRTtRQUNyQixlQUFlLEdBQUcsSUFBSSxDQUFDO0lBQzNCLENBQUMsQ0FBQyxDQUFDO0lBQ0gsSUFBSTtRQUNBLElBQUksT0FBTyxLQUFLLENBQUMsS0FBSyxLQUFLLFdBQVcsRUFBRTtZQUNwQyxNQUFNLEtBQWdDLEtBQUssQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLEVBQXJELEVBQUUsV0FBVyxPQUF3QyxFQUFuQyxTQUFTLGNBQTNCLGVBQTZCLENBQXdCLENBQUM7WUFDNUQsSUFBSSxTQUE4QixDQUFDO1lBQ25DLE1BQU0sZ0JBQWdCLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUMvQyxpRUFBaUU7WUFDakUsa0VBQWtFO1lBQ2xFLHFCQUFxQjtZQUNyQixNQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsZ0JBQWdCLENBQUM7WUFDMUUsSUFBSSxXQUFXLGFBQVgsV0FBVyx1QkFBWCxXQUFXLENBQUUsT0FBTyxFQUFFO2dCQUN0QixTQUFTLEdBQUcsTUFBTSxPQUFPLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDO2FBQ25EO2lCQUFNO2dCQUNILFNBQVMsR0FBRyxNQUFNLE9BQU8sQ0FBQyxXQUFXLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDO2FBQy9EO1lBQ0QsS0FBSyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQzNDO1FBQ0QsSUFBSSxLQUFLLENBQUMsUUFBUSxFQUFFO1lBQ2hCLE1BQU0sS0FBbUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsRUFBM0QsRUFBRSxXQUFXLE9BQThDLEVBQXpDLFlBQVksY0FBOUIsZUFBZ0MsQ0FBMkIsQ0FBQztZQUNsRSxJQUFJLFdBQVcsYUFBWCxXQUFXLHVCQUFYLFdBQVcsQ0FBRSxPQUFPLEVBQUU7Z0JBQ3RCLE1BQU0sT0FBTyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7YUFDekQ7aUJBQU07Z0JBQ0gsTUFBTSxPQUFPLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLEVBQUUsS0FBSyxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsRUFBRSxZQUFZLENBQUMsQ0FBQzthQUNsRztTQUNKO1FBQ0QsVUFBSSxLQUFLLENBQUMsUUFBUSwwQ0FBRSxNQUFNLEVBQUU7WUFDeEIsTUFBTSxrQkFBVSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxFQUFFO2dCQUMvQyxNQUFNLEtBQW1DLE9BQU8sQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLEVBQTdELEVBQUUsV0FBVyxPQUFnRCxFQUEzQyxZQUFZLGNBQTlCLGVBQWdDLENBQTZCLENBQUM7Z0JBQ3BFLElBQUksV0FBVyxhQUFYLFdBQVcsdUJBQVgsV0FBVyxDQUFFLE9BQU8sRUFBRTtvQkFDdEIsTUFBTSxPQUFPLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztpQkFDM0Q7cUJBQU07b0JBQ0gsTUFBTSxPQUFPLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLEVBQUUsT0FBTyxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsRUFBRSxZQUFZLENBQUMsQ0FBQztpQkFDdEc7Z0JBQ0QsTUFBTSxrQkFBVSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxFQUFFO29CQUNqRCxJQUFJLEtBQUssQ0FBQyxLQUFLLEVBQUU7d0JBQ2IsTUFBTSxPQUFPLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLEVBQUUsT0FBTyxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQztxQkFDdkY7eUJBQU07d0JBQ0gsTUFBTSxPQUFPLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLEVBQUUsT0FBTyxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQztxQkFDN0Y7Z0JBQ0wsQ0FBQyxDQUFDLENBQUM7WUFDUCxDQUFDLENBQUMsQ0FBQztTQUNOO0tBQ0o7WUFBUztRQUNOLElBQUksQ0FBQyxlQUFlLEVBQUU7WUFDbEIsTUFBTSxPQUFPLENBQUMsS0FBSyxFQUFFLENBQUM7U0FDekI7S0FDSjtBQUNMLENBQUMsQ0FBQztBQUVXLFFBQUEsWUFBWSxHQUFHLENBQXlDLEtBQWEsRUFBRSxFQUFFLENBQ2xGLENBQUMsS0FBMEMsRUFBK0IsRUFBRSxDQUFDLENBQUM7SUFDMUUsSUFBSSxFQUFFLGVBQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUM7SUFDM0IsS0FBSyxFQUFFLFFBQVEsQ0FBQyxLQUFLLENBQUM7SUFDdEIsT0FBTyxFQUFFLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUM7Q0FDcEMsQ0FBQyxDQUFDO0FBSU0sUUFBQSxhQUFhLEdBQUcsQ0FBbUIsS0FBMEMsRUFBbUMsRUFBRTtJQUMzSCxNQUFNLFlBQVksR0FBRywwQkFBa0IsQ0FBQyxxQkFBd0QsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3pHLHFDQUNJLFlBQVksRUFDWixRQUFRLEVBQUUsR0FBRyxFQUFFLENBQUMsS0FBSyxJQUNsQixvQkFBWSxDQUFDLHFCQUF3RCxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQ2hGLE9BQU8sRUFBRSx5QkFBaUIsQ0FBVyxLQUFLLENBQUMsRUFDM0MsR0FBRyxFQUFFLHFCQUFhLENBQW1CLEtBQUssQ0FBQyxFQUMzQyxTQUFTLEVBQUUsQ0FBQyxTQUFTLEdBQUcsSUFBSSxFQUFFLEVBQUU7WUFDNUIsT0FBTyxxQkFBYSxDQUFDLGFBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDdEQsQ0FBQyxJQUNIO0FBQ04sQ0FBQyxDQUFDO0FBSVcsUUFBQSxVQUFVLEdBQUcsQ0FBbUIsS0FBMEMsRUFBZ0MsRUFBRTtJQUNySCxNQUFNLFlBQVksR0FBRywwQkFBa0IsQ0FBQyxrQkFBa0QsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ25HLHFDQUNJLFlBQVksSUFDVCxvQkFBWSxDQUFDLGtCQUFrRCxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQzFFLE9BQU8sRUFBRSxzQkFBYyxDQUFXLEtBQUssQ0FBQyxFQUN4QyxHQUFHLEVBQUUsa0JBQVUsQ0FBbUIsS0FBSyxDQUFDLEVBQ3hDLFFBQVEsRUFBRSxHQUFHLEVBQUUsQ0FBQyxLQUFLLEVBQ3JCLFNBQVMsRUFBRSxLQUFLLEVBQWdDLEVBQTJGLEVBQUUsRUFBRTs7WUFDM0ksTUFBTSxRQUFRLEdBQUcsTUFBTSx1QkFBWSxDQUFDLEVBQUUsRUFBRSxLQUFLLENBQUMsaUJBQWlCLEVBQUU7Z0JBQzdELE9BQU8sUUFBRSxLQUFLLENBQUMsT0FBTyxtQ0FBSSxJQUFJO2dCQUM5QixJQUFJLFFBQUUsS0FBSyxDQUFDLElBQUksbUNBQUksSUFBSTtnQkFDeEIsVUFBVSxFQUFFLEtBQUssQ0FBQyxVQUFVO2dCQUM1QixTQUFTLFFBQUUsS0FBSyxDQUFDLFNBQVMsbUNBQUksS0FBSztnQkFDbkMsUUFBUSxFQUFFLEtBQUssQ0FBQyxRQUFRO2dCQUN4QixLQUFLLEVBQUUsS0FBSyxDQUFDLEtBQUs7Z0JBQ2xCLFdBQVcsUUFBRSxLQUFLLENBQUMsV0FBVyxtQ0FBSSxJQUFJO2dCQUN0QyxPQUFPLEVBQUUsS0FBSyxDQUFDLE9BQU87Z0JBQ3RCLEtBQUssUUFBRSxLQUFLLENBQUMsS0FBSyxtQ0FBSSxLQUFLO2dCQUMzQixRQUFRLEVBQUUsS0FBSyxDQUFDLFFBQVE7Z0JBQ3hCLFNBQVMsUUFBRSxLQUFLLENBQUMsU0FBUyxtQ0FBSSxLQUFLO2dCQUNuQyxLQUFLLEVBQUUsUUFBUSxDQUFDLEtBQUssQ0FBQzthQUN6QixFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNkLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDOUMsT0FBTyxRQUFRLENBQUM7UUFDcEIsQ0FBQyxFQUNELE9BQU8sRUFBRSxDQUFDLE9BQU8sR0FBRyxJQUFJLEVBQUUsRUFBRTtZQUN4QixPQUFPLGtCQUFVLENBQUMsYUFBSyxDQUFDLEtBQUssRUFBRSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNqRCxDQUFDLEVBQ0QsUUFBUSxFQUFFLENBQUMsUUFBUSxHQUFHLENBQUMsRUFBRSxFQUFFO1lBQ3ZCLE9BQU8sa0JBQVUsQ0FBQyxhQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ2xELENBQUMsRUFDRCxXQUFXLEVBQUUsQ0FBQyxXQUFXLEdBQUcsSUFBSSxFQUFFLEVBQUU7WUFDaEMsT0FBTyxrQkFBVSxDQUFDLGFBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDckQsQ0FBQyxFQUNELFNBQVMsRUFBRSxDQUFDLFNBQVMsR0FBRyxJQUFJLEVBQUUsRUFBRTtZQUM1QixPQUFPLGtCQUFVLENBQUMsYUFBSyxDQUFDLEtBQUssRUFBRSxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNuRCxDQUFDLEVBQ0QsT0FBTyxFQUFFLENBQUMsT0FBdUIsRUFBRSxFQUFFO1lBQ2pDLE9BQU8sa0JBQVUsQ0FBQyxhQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ2pELENBQUMsRUFDRCxTQUFTLEVBQUUsQ0FBQyxTQUFTLEdBQUcsSUFBSSxFQUFFLEVBQUU7WUFDNUIsT0FBTyxrQkFBVSxDQUFDLGFBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDbkQsQ0FBQyxFQUNELEdBQUcsRUFBRSxDQUFDLEdBQUcsVUFBMEMsRUFBRSxFQUFFO1lBQ25ELE9BQU8sa0JBQVUsQ0FBQyxhQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsVUFBVSxFQUFFLENBQUMsS0FBSyxDQUFDLFVBQVUsSUFBSSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDakcsQ0FBQyxFQUNELEtBQUssRUFBRSxDQUFDLEtBQUssR0FBRyxJQUFJLEVBQUUsRUFBRTtZQUNwQixPQUFPLGtCQUFVLENBQUMsYUFBSyxDQUFDLEtBQUssRUFBRSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztRQUMvQyxDQUFDLEVBQ0QsUUFBUSxFQUFFLENBQUMsUUFBZ0IsRUFBRSxFQUFFO1lBQzNCLE9BQU8sa0JBQVUsQ0FBQyxhQUFLLENBQUMsS0FBSyxFQUFFLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ2xELENBQUMsRUFDRCxTQUFTLEVBQUUsQ0FBQyxTQUFTLEdBQUcsSUFBSSxFQUFFLEVBQUU7WUFDNUIsT0FBTyxrQkFBVSxDQUFDLGFBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDbkQsQ0FBQyxJQUNIO0FBQ04sQ0FBQyxDQUFDO0FBRVcsUUFBQSxVQUFVLEdBQUcsQ0FBbUIsS0FBa0QsRUFBRSxFQUFFLENBQy9GLEtBQUssRUFBRSxPQUFpQixFQUFFLElBQXFCLEVBQUUsRUFBRTtJQUMvQyxNQUFNLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO0lBQ3hCLE1BQU0sYUFBYSxHQUFHLDJCQUFxQixFQUFFLENBQUM7SUFDOUMsTUFBTSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsR0FBRyxNQUFNLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQVMsYUFBYSxDQUFDLENBQUM7SUFDcEYsTUFBTSxjQUFjLEdBQUcsV0FBVyxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQztTQUM5RCxhQUFhLENBQUMsYUFBYSxDQUFDO1NBQzVCLE9BQU8sQ0FBQyxLQUFLLENBQUM7U0FDZCxRQUFRLEVBQUUsQ0FBQztJQUNoQixNQUFNLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUMvQyxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxFQUNyQixNQUFNLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsRUFDbkMsY0FBYyxDQUFDLE9BQWlDLEVBQ2hELEtBQUssQ0FBQyxPQUFPLENBQ2hCLENBQUM7SUFDRixPQUFPLE9BQU8sQ0FBQztBQUNuQixDQUFDLENBQUM7QUFpQk8sUUFBQSxhQUFhLEdBQUcsQ0FBbUIsS0FBa0QsRUFBbUMsRUFBRSxDQUNuSSxLQUFLLEVBQUUsT0FBbUQsRUFBRSxVQUFtQixFQUFFLFVBQTJCLEVBQUUsRUFBRSxFQUFFO0lBQzlHLE1BQU0sUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7SUFDeEIsTUFBTSxhQUFhLEdBQUcsMkJBQXFCLEVBQUUsQ0FBQztJQUM5QyxNQUFNLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxHQUFHLE1BQU0sS0FBSyxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBUyxhQUFhLENBQUMsQ0FBQztJQUNwRixNQUFNLGNBQWMsR0FBRyxXQUFXLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsT0FBTyxDQUFDO1NBQ2xFLGFBQWEsQ0FBQyxhQUFhLENBQUM7U0FDNUIsT0FBTyxDQUFDLEtBQUssQ0FBQztTQUNkLFFBQVEsRUFBRSxDQUFDO0lBQ2hCLE1BQU0sS0FBSyxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxpQkFBaUIsQ0FDckQsS0FBSyxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsRUFDeEIsY0FBYyxDQUFDLFVBQVUsRUFDekIsTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLEVBQ25DLGNBQWMsQ0FBQyxPQUFpQyxFQUNoRCxLQUFLLENBQUMsT0FBTyxDQUNoQixDQUFDO0lBQ0YsT0FBTyxPQUFPLENBQUM7QUFDbkIsQ0FBQyxDQUFDO0FBRU4sTUFBTSxXQUFXLEdBQUcsQ0FDaEIsS0FBa0QsRUFDbEQsT0FBbUQsRUFDbkQsVUFBbUIsRUFDbkIsVUFBMkIsRUFBRSxFQUNQLEVBQUU7SUFDeEIsSUFBSSxDQUFDLDBDQUF1QixDQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ25DLElBQUksS0FBSyxDQUFDLElBQUksRUFBRTtZQUNaLE9BQU8sR0FBRyxrQ0FBZSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUMvQzthQUFNO1lBQ0gsT0FBTyxHQUFHLGtDQUFlLENBQUMsRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLE9BQWlCLENBQUMsQ0FBQztTQUMvRDtLQUNKO0lBQ0QsSUFBSSxVQUFVLEVBQUU7UUFDWixPQUFPLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsQ0FBQztLQUM1QztJQUNELE9BQU8sR0FBRyxrQ0FBZSxDQUFDLG9DQUFpQixDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQztJQUM5RSxPQUFPLE9BQU8sQ0FBQztBQUNuQixDQUFDLENBQUM7QUFFVyxRQUFBLGNBQWMsR0FBRyxDQUFXLEtBQTBDLEVBQUUsRUFBRSxDQUNuRixLQUFLLEVBQUUsT0FBMEMsRUFBRSxVQUEyQixFQUFFLEVBQUUsRUFBRTtJQUNoRixNQUFNLGNBQWMsR0FBRyxXQUFXLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDbEYsTUFBTSxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQztJQUN4QixPQUFPLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUNoRCxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxFQUNyQixNQUFNLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsRUFDbkMsY0FBYyxDQUFDLE9BQWlDLEVBQ2hELEtBQUssQ0FBQyxPQUFPLENBQ2hCLENBQUM7QUFDTixDQUFDLENBQUM7QUFpQk8sUUFBQSxpQkFBaUIsR0FBRyxDQUFXLEtBQTBDLEVBQStCLEVBQUUsQ0FDbkgsS0FBSyxFQUFFLE9BQW1ELEVBQUUsVUFBbUIsRUFBRSxPQUF5QixFQUFFLEVBQUU7SUFDMUcsTUFBTSxjQUFjLEdBQUcsV0FBVyxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLE9BQU8sQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ25GLE1BQU0sUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7SUFDeEIsT0FBTyxLQUFLLENBQUMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLGlCQUFpQixDQUN0RCxLQUFLLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFBRSxFQUN4QixjQUFjLENBQUMsVUFBVSxFQUN6QixNQUFNLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsRUFDbkMsY0FBYyxDQUFDLE9BQWlDLEVBQ2hELEtBQUssQ0FBQyxPQUFPLENBQ2hCLENBQUM7QUFDTixDQUFDLENBQUM7QUFFTyxRQUFBLFFBQVEsR0FBRyxDQUEwQixLQUFRLEVBQUUsRUFBRSxDQUMxRCxDQUFDLEtBQWdDLEVBQUUsRUFBRSxDQUNqQyxDQUFDLEtBQXFCLEVBQUUsT0FBNEIsRUFBRSxFQUFFLEVBQUU7SUFDdEQsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7UUFDM0IsS0FBSyxHQUFHLHVCQUFlLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO0tBQ3hDO0lBQ0QsT0FBTyxLQUFLLENBQUMsYUFBSyxDQUFDLEtBQUssRUFBRSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztBQUMxQyxDQUFDLENBQUM7QUFFRyxRQUFBLFdBQVcsR0FBRyxDQUEwQixLQUFRLEVBQUUsRUFBRSxDQUM3RCxDQUFDLEtBQWdDLEVBQUUsRUFBRSxDQUNqQyxDQUFDLFFBQTJCLEVBQUUsSUFBa0IsRUFBRSxPQUFpQyxFQUFFLEVBQUUsRUFBRTtJQUNyRixJQUFJLE9BQU8sUUFBUSxLQUFLLFFBQVEsRUFBRTtRQUM5QixRQUFRLEdBQUcsNkJBQWtCLENBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztLQUN2RDtJQUNELE9BQU8sS0FBSyxDQUFDLGFBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDN0MsQ0FBQyxDQUFDO0FBRUcsUUFBQSxrQkFBa0IsR0FBRyxDQUF5RyxLQUFhLEVBQUUsRUFBRSxDQUN4SixDQUFDLEtBQTBDLEVBQUUsRUFBRSxDQUMzQyxDQUNJLFFBQW9DLEVBQ3BDLE9BQTBCLEVBQzFCLElBQW1CLEVBQ25CLE9BQWlDLEVBQUUsRUFDckMsRUFBRTtJQUNBLElBQUksT0FBTyxRQUFRLEtBQUssUUFBUSxFQUFFO1FBQzlCLFFBQVEsR0FBRyw2QkFBa0IsQ0FBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0tBQ3ZEO0lBQ0QsT0FBTyxLQUFLLENBQUMsYUFBSyxDQUFDLEtBQUssRUFBRSxFQUFFLFFBQVEsRUFBRSxDQUFDLEtBQUssQ0FBQyxRQUFRLElBQUksRUFBRSxDQUFDO2FBQ3ZELE1BQU0sQ0FBQyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFrRCxDQUFDO0FBQ2pILENBQUMsQ0FBQztBQUVWLE1BQU0sVUFBVSxHQUFHLENBQTBCLEtBQVEsRUFBRSxFQUFFLENBQ3JELENBQUMsS0FBZ0MsRUFBRSxFQUFFLENBQ2pDLENBQUMsT0FBTyxHQUFHLElBQUksRUFBRSxFQUFFLENBQ2YsS0FBSyxDQUFDLGFBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFrQixDQUFDO0FBRWpELFFBQUEsT0FBTyxHQUFHLENBQTBCLEtBQVEsRUFBRSxFQUFFLENBQ3pELENBQUMsS0FBZ0MsRUFBRSxFQUFFLENBQ2pDLENBQUMsSUFBSSxHQUFHLElBQUksRUFBRSxFQUFFLENBQ1osS0FBSyxDQUFDLGFBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFrQixDQUFDIn0=