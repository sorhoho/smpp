import { HaredoMessage } from './haredo-message';
import { Queue } from './queue';
import { Middleware, Loggers } from './state';
import { Replies } from 'amqplib';
import { ConnectionManager } from './connection-manager';
import { TypedEventEmitter } from './events';
import { FailureBackoff } from './backoffs';
export interface MessageCallback<TMessage = unknown, TReply = unknown> {
    (message: HaredoMessage<TMessage, TReply>): Promise<TReply | void> | TReply | void;
}
export interface ConsumerOpts {
    prefetch: number;
    autoAck: boolean;
    autoReply: boolean;
    json: boolean;
    queue: Queue;
    reestablish: boolean;
    noAck: boolean;
    priority: number;
    exclusive: boolean;
    backoff: FailureBackoff;
    setup(): Promise<any>;
    middleware: Middleware<unknown, unknown>[];
}
export interface ConsumerEvents {
    close: never;
    reestablished: never;
    error: Error;
    'message-error': Error;
}
export interface Consumer {
    emitter: TypedEventEmitter<ConsumerEvents>;
    isClosing: boolean;
    isClosed: boolean;
    /**
     * Wait for all current messages to finish and then close the consumer
     */
    close(): Promise<void>;
    /**
     * Change the prefetch
     * @param prefetch Amount of messages to be unacked in the consumer
     */
    prefetch(prefetch: number): Replies.Empty;
}
export declare const makeConsumer: <TMessage = unknown, TReply = unknown>(cb: MessageCallback<TMessage, TReply>, connectionManager: ConnectionManager, opts: ConsumerOpts, log: Loggers) => Promise<Consumer>;
export declare const applyMiddleware: <TMessage, TReply>(middleware: Middleware<TMessage, TReply>[], cb: MessageCallback<TMessage, TReply>, msg: HaredoMessage<TMessage, TReply>, autoAck: boolean, autoReply: boolean, log: Loggers) => Promise<void>;
